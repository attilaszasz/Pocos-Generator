#! "netcoreapp2.1"
#r "nuget:System.Configuration.ConfigurationManager,4.5.0"
#r "nuget:Microsoft.Extensions.Configuration.Json,2.1.1"
#r "nuget:System.Data.Common,4.3.0"
#r "nuget:System.Data.SqlClient,4.5.1"

using System.Data;
using System.Data.Common;
using System.Data.SqlClient;
using System.Globalization;
using System.Text.RegularExpressions;
using Microsoft.Extensions.Configuration;

var Params = new Dictionary<string, string>();
const string ParamSeparator = ":";

foreach (var arg in Args)
{
    var index = @arg.IndexOf(ParamSeparator);
	if (index > -1){
		Params.Add(arg.Substring(0, index).ToLowerInvariant(), arg.Substring(index + 1));
	}
}

var options = new PocosGeneratorOptions {
	Output = Params.ContainsKey("output") ? Params["output"] : "DbModels.cs",
	ConfigFilePath = Params.ContainsKey("config") ? Params["config"] : "appsettings.json",
	ConnectionStringName = Params.ContainsKey("connectionstring") ? Params["connectionstring"] : "ConnectionStrings:DefaultConnection",
	Namespace = Params.ContainsKey("namespace") ? Params["namespace"] : "Models",
	SpClass = Params.ContainsKey("spclass") ? Params["spclass"] : null,
	TvpClass = Params.ContainsKey("tvpclass") ? Params["tvpclass"] : null,
	DapperContribAttributes = Params.ContainsKey("dapper") && Params["dapper"] == "true",
    ClassPrefix = Params.ContainsKey("classprefix") ? Params["classprefix"] : null,
    ClassSuffix = Params.ContainsKey("classsufix") ? Params["classsufix"] : null,
    GeneratePocos = Params.ContainsKey("pocos") && Params["pocos"] == "false" ? false : true,
    IncludeViews = Params.ContainsKey("views") && Params["views"] == "false" ? false : true,
    SchemaName = Params.ContainsKey("schema") ? Params["schema"] : null
};

public class PocosGenerator {
	private readonly PocosGeneratorOptions _options;
	private readonly SchemaReader reader;
    private DbConnection _connection;
	private StringBuilder builder;
	public Tables Tables = null;
	private List<string> splist = null;
	private Dictionary<string, List<string>> tvplist = null;
	public string ConnectionString;

	public PocosGenerator(PocosGeneratorOptions options){
		_options = options;
		reader = GetSchemaReader();
		ConnectionString = GetConnectionString();
		builder = new StringBuilder();
	}

	public void GenerateClass(){
		builder.AppendLine("// <auto-generated />");
		builder.AppendLine("//");
		builder.AppendLine("// This file was automatically generated by PocosGenerator.csx, inspired from the PetaPoco T4 Template");
		builder.AppendLine("// Do not make changes directly to this file - edit the PocosGenerator.GenerateClass() method in the PocosGenerator.Core.csx file instead");
		builder.AppendLine("// ");
		builder.AppendLine("");
		builder.AppendLine("using System;");
		if (_options.DapperContribAttributes) builder.AppendLine("using Dapper.Contrib.Extensions;");
		builder.AppendLine("using System.Collections.Generic;");
		builder.AppendLine("");
		builder.AppendLine($"namespace {_options.Namespace}");
		builder.AppendLine("{");
		builder.AppendLine("    // ReSharper disable InconsistentNaming");

		if (_options.GeneratePocos){
			foreach (Table tbl in from t in Tables where !t.Ignore select t){
				builder.AppendLine("");
				if (_options.DapperContribAttributes) builder.AppendLine($"    [Table(\"{tbl.Name}\")]");
				builder.AppendLine($"    public partial class {tbl.ClassName}");
				builder.AppendLine("    {");
				foreach(Column col in from c in tbl.Columns where !c.Ignore select c)
				{
					// Column bindings
					if (_options.DapperContribAttributes && col.IsPK){
						builder.AppendLine("        [Key]");
					}
					builder.AppendLine($"        public {col.PropertyType}{CheckNullable(col)} {col.PropertyName} {{ get; set; }}");
				}
				builder.AppendLine("    }");
			}
		}

		if (!string.IsNullOrWhiteSpace(_options.SpClass)){
			builder.AppendLine("");
			builder.AppendLine("    /// <summary>");
			builder.AppendLine($"    /// {_options.SpClass} is a static class holding the list of stored procedures of the {_options.ConnectionStringName} database.");
			builder.AppendLine("    /// This makes passing paramaters clearer and at the same time will prevent typos and the resulting runtime errors.");
			builder.AppendLine("    /// </summary>");
			builder.AppendLine("    /// <remarks>");
			builder.AppendLine("    /// The class is dynamically generated by running our poco generator");
			builder.AppendLine("    /// </remarks>");
			builder.AppendLine($"    public static partial class {_options.SpClass} {{");
			foreach (string sp in splist){
				builder.AppendLine($"        public const string {CleanUpStoredProcName(sp)} = \"{sp}\"");
			}
			builder.AppendLine("    }");
		}

		if (!string.IsNullOrWhiteSpace(_options.TvpClass)){
			builder.AppendLine("");
			builder.AppendLine("    /// <summary>");
			builder.AppendLine($"    /// {_options.TvpClass} is a static class holding the list of Table Valued Parameters of the {_options.ConnectionStringName} database.");
			builder.AppendLine("    /// This makes calling stored procedures clearer and at the same time will prevent typos and the resulting runtime errors.");
			builder.AppendLine("    /// </summary>");
			builder.AppendLine("    /// <remarks>");
			builder.AppendLine("    /// The class is dynamically generated by running our poco generator");
			builder.AppendLine("    /// </remarks>");
			builder.AppendLine($"    public static partial class {_options.TvpClass} {{");
			foreach (var tvp in tvplist){
				builder.AppendLine($"        public static class {CleanUpTVPName(tvp.Key)} {{");
				builder.AppendLine($"            public const string Name = \"{tvp.Key}\";");
				builder.AppendLine($"            public static List<string> Columns = new List<string> {{");
				foreach (var column in tvp.Value) {
					builder.AppendLine($"            \"{column}\",");

				}
				builder.AppendLine("            }");
				builder.AppendLine("        }");
			}
			builder.AppendLine("    }");
		}

		builder.AppendLine("}");

	}

	public bool ReadSchema(){

		using (DbConnection conn = InitDbConnection()){
			Tables = LoadTables();
			splist = LoadStoredProcedures();
			tvplist = LoadTVPs();
		}

		return Tables.Any() || splist.Any() || tvplist.Any();
	}

	public string Content {get => builder.ToString();}

	private SchemaReader GetSchemaReader(){
	switch (_options.DbType){
		case DatabaseType.MySql: return new MySqlSchemaReader();
		case DatabaseType.Oracle: return new OracleSchemaReader();
		case DatabaseType.PostgreSQL: return new PostGreSqlSchemaReader();
		case DatabaseType.SQL_CE: return new SqlServerCeSchemaReader();
		default: return new SqlServerSchemaReader();
		}
	}

	//Todo: add connection types for other Db's
	private DbConnection GetDbConnection(){
		switch (_options.DbType){
			case DatabaseType.MySql:
			case DatabaseType.Oracle:
			case DatabaseType.PostgreSQL:
			case DatabaseType.SQL_CE:
			default: return new SqlConnection(ConnectionString);
		}
	}

	public DbConnection InitDbConnection(){
		_connection = GetDbConnection();
		return _connection;
	}

	private string GetConnectionString()
	{
		string separator1 = Path.DirectorySeparatorChar.ToString();
        string separator2 = Path.AltDirectorySeparatorChar.ToString();
        var path = Directory.GetCurrentDirectory().TrimEnd();
        if (!path.EndsWith(separator1) || !path.EndsWith(separator2)){
            if (path.Contains(separator2)){
                path = path + separator2;
            } else {
                path = path + separator1;
            }
        }
        var fullPath = Path.GetFullPath(path + _options.ConfigFilePath);
		var appSettings = new ConfigurationBuilder().AddJsonFile(fullPath, optional: false).Build();
		var connStr = appSettings[_options.ConnectionStringName];
		return connStr;
	}

	private Tables LoadTables()
	{
		try
		{
			Tables result;
			try
			{
				_connection.ConnectionString=ConnectionString;         
				_connection.Open();

				result=reader.ReadSchema(_connection);

				// Remove unrequired tables/views
				for (int i=result.Count-1; i>=0; i--)
				{
					if (_options.SchemaName!=null && string.Compare(result[i].Schema, _options.SchemaName, true)!=0)
					{
						result.RemoveAt(i);
						continue;
					}
					if (!_options.IncludeViews && result[i].IsView)
					{
						result.RemoveAt(i);
						continue;
					}
				}

				_connection.Close();


				var rxClean = new Regex("^(Equals|GetHashCode|GetType|ToString|repo|Save|IsNew|Insert|Update|Delete|Exists|SingleOrDefault|Single|First|FirstOrDefault|Fetch|Page|Query)$");
				foreach (var t in result)
				{
					t.ClassName = _options.ClassPrefix + t.ClassName + _options.ClassSuffix;
					foreach (var c in t.Columns)
					{
						c.PropertyName = rxClean.Replace(c.PropertyName, "_$1");

						// Make sure property name doesn't clash with class name
						if (c.PropertyName == t.ClassName)
							c.PropertyName = "_" + c.PropertyName;
					}
				}
			}
			catch (Exception x)
			{
				var error=x.Message.Replace("\r\n", "\n").Replace("\n", " ");
				WriteLine(string.Format("Failed to load data `{0}`", error));
				builder.AppendLine("");
				builder.AppendLine("// -----------------------------------------------------------------------------------------");
				builder.AppendLine($"// Failed to load data `{error}`");
				builder.AppendLine("// -----------------------------------------------------------------------------------------");
				builder.AppendLine("");
				return new Tables();
			}

			return result;
		}
		catch (Exception x)
		{
			var error=x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			WriteLine(string.Format("Failed to read database schema - {0}", error));
			builder.AppendLine("");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine("// Failed to read database schema - {error}");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine("");
			return new Tables();
		}
	}

	private List<string> LoadStoredProcedures()
	{
		try
		{
			List<string> result;
			_connection.ConnectionString = ConnectionString;         
			_connection.Open();

			result=reader.GetStoredProcedures(_connection);

			_connection.Close();

			return result;
		}
		catch (Exception x)
		{
			var error=x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			WriteLine(string.Format("Failed to read database schema - {0}", error));
			builder.AppendLine("");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine($"// Failed to read database schema - {error}");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine("");
			return new List<string>();
		}
	}

	private Dictionary<string, List<string>> LoadTVPs()
	{
		try
		{
			Dictionary<string, List<string>> result;
			_connection.ConnectionString = ConnectionString;         
			_connection.Open();
		
			result=reader.GetTVPs(_connection);

			_connection.Close();

			return result;
		}
		catch (Exception x)
		{
			var error=x.Message.Replace("\r\n", "\n").Replace("\n", " ");
			WriteLine(string.Format("Failed to read database schema - {0}", error));
			builder.AppendLine("");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine($"// Failed to read database schema - {error}");
			builder.AppendLine("// -----------------------------------------------------------------------------------------");
			builder.AppendLine("");
			return new Dictionary<string, List<string>>();
		}
	}

	private static string CheckNullable(Column col)
	{
		string result="";
		if(col.IsNullable && 
			col.PropertyType !="byte[]" && 
			col.PropertyType !="string" &&
			col.PropertyType !="Microsoft.SqlServer.Types.SqlGeography" &&
			col.PropertyType !="Microsoft.SqlServer.Types.SqlGeometry"
			)
			result="?";
		return result;
	}

	private static Func<string, string> CleanUpStoredProcName = (str) =>
	{
		if (str.StartsWith("sp_", StringComparison.OrdinalIgnoreCase)) {
			str = str.Remove(0, 3);
		}
		else if (str.StartsWith("sp", StringComparison.OrdinalIgnoreCase)) {
			str = str.Remove(0, 2);
		}
			
		return str.Replace('.','_');
	};

	private static Func<string, string> CleanUpTVPName = (str) =>
	{
		return str.Replace('.','_');
	};
}

public enum DatabaseType {
	MySql,
	SQL_CE,
	PostgreSQL,
	Oracle,
	SQLServer
}

public class PocosGeneratorOptions {
	public string Output {get;set;}
	public string ConnectionStringName {get;set;}
	/// Namespace for the generated class
	public string Namespace {get;set;}
	public string ClassPrefix {get;set;}
	public string ClassSuffix {get;set;}
	public string SchemaName {get;set;}
	public bool IncludeViews {get;set;}
	public bool GeneratePocos {get;set;}
	public bool DapperContribAttributes {get;set;}
	/// If left blank, class with stored procedure names won't be generated
	public string SpClass {get;set;}
	/// If left blank, class with Table Valued Parameters won't be generated
	public string TvpClass {get;set;}
	public DatabaseType DbType {get;set;} = DatabaseType.SQLServer;
	/// Relative path to script
	public string ConfigFilePath {get;set;}  
}

public class Table
{
    public List<Column> Columns;	
    public string Name;
	public string Schema;
	public bool IsView;
    public string CleanName;
    public string ClassName;
	public string SequenceName;
	public bool Ignore;

    public Column PK
    {
        get
        {
            return this.Columns.SingleOrDefault(x=>x.IsPK);
        }
    }

	public Column GetColumn(string columnName)
	{
		return Columns.Single(x=>string.Compare(x.Name, columnName, true)==0);
	}

	public Column this[string columnName]
	{
		get
		{
			return GetColumn(columnName);
		}
	}

}

public class Column
{
    public string Name;
    public string PropertyName;
    public string PropertyType;
    public bool IsPK;
    public bool IsNullable;
	public bool IsAutoIncrement;
	public bool Ignore;
}

public class Tables : List<Table>
{
	public Tables()
	{
	}
	
	public Table GetTable(string tableName)
	{
		return this.Single(x=>string.Compare(x.Name, tableName, true)==0);
	}

	public Table this[string tableName]
	{
		get
		{
			return GetTable(tableName);
		}
	}

}

static Regex rxCleanUp = new Regex(@"[^\w\d_]", RegexOptions.Compiled);


static Func<string, string> CleanUp = (str) =>
{
	str = rxCleanUp.Replace(str, "_");
	if (char.IsDigit(str[0])) str = "_" + str;
	
    return str;
};

static string zap_password(string connectionString)
{
	var rx = new Regex("password=.*;", RegexOptions.Singleline | RegexOptions.Multiline | RegexOptions.IgnoreCase);
	return rx.Replace(connectionString, "password=**zapped**;");
}


public abstract class SchemaReader
{
	public abstract Tables ReadSchema(DbConnection connection);
	public abstract List<string> GetStoredProcedures(DbConnection connection);
	public abstract Dictionary<string, List<string>> GetTVPs(DbConnection connection);
}

public class SqlServerSchemaReader : SchemaReader
{
	public override List<string> GetStoredProcedures(DbConnection connection)
	{
		var result = new List<string>();
		
		_connection = connection;

		var cmd = _connection.CreateCommand();
		cmd.Connection = connection;
		cmd.CommandText = @"SELECT * 
						    FROM INFORMATION_SCHEMA.ROUTINES 
						    WHERE routine_type = 'PROCEDURE'
							  AND LEFT(Routine_Name, 3) NOT IN ('sp_', 'xp_', 'ms_')
							  AND LEFT(Routine_Name, 6) NOT IN ('spEMT_', 'spFXT_')
							ORDER BY Routine_Name";

		// pull the SP list in a reader
		using(cmd)
		{
			using (var rdr = cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					result.Add($"{rdr["Specific_Schema"]}.{rdr["Routine_Name"]}");
				}
			}
		}

		return result;
	}	
	
	public override Dictionary<string, List<string>> GetTVPs(DbConnection connection)
	{
		var result = new Dictionary<string, List<string>>();
		
		_connection = connection;

		var cmd = _connection.CreateCommand();
		cmd.Connection = connection;
		cmd.CommandText = @"select
								s.name as [Schema],
								t.name as [Type],
								c.name as [Column]
							from sys.table_types t
							inner join sys.schemas AS s
							  ON t.[schema_id] = s.[schema_id]
							inner join sys.columns c
								on c.[object_id] = t.type_table_object_id
							where is_user_defined = 1";

		// pull the SP list in a reader
		using(cmd)
		{
			using (var rdr = cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					var tvp = $"{rdr["Schema"]}.{rdr["Type"]}";
				    if (result.ContainsKey(tvp))
				    {
				        result[tvp].Add(rdr["Column"].ToString());
				    }
				    else
				    {
				        result.Add(tvp, new List<string>{ rdr["Column"].ToString() });
				    }
				}
			}
		}

		return result;
	}

	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();
		
		_connection=connection;

		var cmd=_connection.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText = TABLE_SQL_INCLUDE_VIEWS; //TableCommandText; // Change - Allows the inclusion of views
		//cmd.CommandText = TABLE_SQL;

		//pull the tables in a reader
		using(cmd)
		{

			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["TABLE_NAME"].ToString();
					tbl.Schema=rdr["TABLE_SCHEMA"].ToString();
					tbl.IsView=string.Compare(rdr["TABLE_TYPE"].ToString(), "View", true)==0;
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=Inflector.MakeSingular(tbl.CleanName);
					tbl.Ignore = true;

					result.Add(tbl);
				}
			}
		}

		foreach (var tbl in result)
		{
			tbl.Columns=LoadColumns(tbl);
		            
			// Mark the primary key
			string PrimaryKey=GetPK(tbl.Name);
			var pkColumn=tbl.Columns.SingleOrDefault(x=>x.Name.ToLower().Trim()==PrimaryKey.ToLower().Trim());
			if(pkColumn!=null)
			{
				pkColumn.IsPK=true;
			}
		}

		return result;
	}
	
	DbConnection _connection;
	

	List<Column> LoadColumns(Table tbl)
	{
	
		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=COLUMN_SQL;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=tbl.Name;
			cmd.Parameters.Add(p);

			p = cmd.CreateParameter();
			p.ParameterName = "@schemaName";
			p.Value=tbl.Schema;
			cmd.Parameters.Add(p);

			//var isFirstColumn = true;
			var result = new List<Column>();
			using (IDataReader rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					// Skip Computed Columns from mapping
					if (((int)rdr["IsComputed"]) != 1)
					{
						Column col=new Column();
						col.Name=rdr["ColumnName"].ToString();
						col.PropertyName=CleanUp(col.Name);
						col.PropertyType=GetPropertyType(rdr["DataType"].ToString());
						col.IsNullable=rdr["IsNullable"].ToString()=="YES";
						col.IsAutoIncrement=((int)rdr["IsIdentity"])==1;

						/*if (isFirstColumn && !col.IsAutoIncrement) {
							if (col.PropertyType == "Guid") { // || col.PropertyName.ToLower() == "id") {
								col.IsAutoIncrement = true;
							}
						}
						isFirstColumn = false;*/

						result.Add(col);
					}
				}
			}

			return result;
		}
	}

	string GetPK(string table){
		
		string sql=@"SELECT c.name AS ColumnName
                FROM sys.indexes AS i 
                INNER JOIN sys.index_columns AS ic ON i.object_id = ic.object_id AND i.index_id = ic.index_id 
                INNER JOIN sys.objects AS o ON i.object_id = o.object_id 
                LEFT OUTER JOIN sys.columns AS c ON ic.object_id = c.object_id AND c.column_id = ic.column_id
                WHERE (i.is_primary_key = 1) AND (o.name = @tableName)";

		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=sql;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=table;
			cmd.Parameters.Add(p);

			var result=cmd.ExecuteScalar();

			if(result!=null)
				return result.ToString();    
		}	         
		
		return "";
	}
	
	string GetPropertyType(string sqlType)
	{
		string sysType="string";
		switch (sqlType) 
		{
			case "bigint":
				sysType = "long";
				break;
			case "smallint":
				sysType= "short";
				break;
			case "int":
				sysType= "int";
				break;
			case "uniqueidentifier":
				sysType=  "Guid";
				 break;
			case "smalldatetime":
			case "datetime":
			case "date":
			case "time":
				sysType=  "DateTime";
				  break;
			case "float":
				sysType="double";
				break;
			case "real":
				sysType="float";
				break;
			case "numeric":
			case "smallmoney":
			case "decimal":
			case "money":
				sysType=  "decimal";
				 break;
			case "tinyint":
				sysType = "byte";
				break;
			case "bit":
				sysType=  "bool";
				   break;
			case "image":
			case "binary":
			case "varbinary":
			case "timestamp":
				sysType=  "byte[]";
				 break;
			case "geography":
				sysType = "Microsoft.SqlServer.Types.SqlGeography";
				break;
			case "geometry":
				sysType = "Microsoft.SqlServer.Types.SqlGeometry";
				break;
		}
		return sysType;
	}


    const string TABLE_SQL_INCLUDE_VIEWS = @"SELECT * FROM  INFORMATION_SCHEMA.TABLES ORDER BY TABLE_NAME";
    const string TABLE_SQL= @"SELECT *
		FROM  INFORMATION_SCHEMA.TABLES
		WHERE TABLE_TYPE='BASE TABLE' OR TABLE_TYPE='VIEW'
		ORDER BY TABLE_NAME";



	const string COLUMN_SQL=@"SELECT 
			TABLE_CATALOG AS [Database],
			TABLE_SCHEMA AS Owner, 
			TABLE_NAME AS TableName, 
			COLUMN_NAME AS ColumnName, 
			ORDINAL_POSITION AS OrdinalPosition, 
			COLUMN_DEFAULT AS DefaultSetting, 
			IS_NULLABLE AS IsNullable, DATA_TYPE AS DataType, 
			CHARACTER_MAXIMUM_LENGTH AS MaxLength, 
			DATETIME_PRECISION AS DatePrecision,
			COLUMNPROPERTY(object_id('[' + TABLE_SCHEMA + '].[' + TABLE_NAME + ']'), COLUMN_NAME, 'IsIdentity') AS IsIdentity,
			COLUMNPROPERTY(object_id('[' + TABLE_SCHEMA + '].[' + TABLE_NAME + ']'), COLUMN_NAME, 'IsComputed') as IsComputed
		FROM  INFORMATION_SCHEMA.COLUMNS
		WHERE TABLE_NAME=@tableName AND TABLE_SCHEMA=@schemaName
		ORDER BY OrdinalPosition ASC";
	  
}


public class SqlServerCeSchemaReader : SchemaReader
{
	public override List<string> GetStoredProcedures(DbConnection connection)
	{
		return new List<string>();
	}

	public override Dictionary<string, List<string>> GetTVPs(DbConnection connection)
    {
        return new Dictionary<string, List<string>>();
    }

	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();
		
		_connection=connection;

		var cmd=_connection.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText=TABLE_SQL;

		//pull the tables in a reader
		using(cmd)
		{
			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["TABLE_NAME"].ToString();
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=Inflector.MakeSingular(tbl.CleanName);
					tbl.Schema=null;
					tbl.IsView=false;
					result.Add(tbl);
				}
			}
		}

		foreach (var tbl in result)
		{
			tbl.Columns=LoadColumns(tbl);
		            
			// Mark the primary key
			string PrimaryKey=GetPK(tbl.Name);
			var pkColumn=tbl.Columns.SingleOrDefault(x=>x.Name.ToLower().Trim()==PrimaryKey.ToLower().Trim());
			if(pkColumn!=null)
				pkColumn.IsPK=true;
		}
	    

		return result;
	}
	
	DbConnection _connection;
	

	List<Column> LoadColumns(Table tbl)
	{
	
		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=COLUMN_SQL;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=tbl.Name;
			cmd.Parameters.Add(p);

			var result=new List<Column>();
			using (IDataReader rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Column col=new Column();
					col.Name=rdr["ColumnName"].ToString();
					col.PropertyName=CleanUp(col.Name);
					col.PropertyType=GetPropertyType(rdr["DataType"].ToString());
					col.IsNullable=rdr["IsNullable"].ToString()=="YES";
					col.IsAutoIncrement=rdr["AUTOINC_INCREMENT"]!=DBNull.Value;
					result.Add(col);
				}
			}

			return result;
		}
	}

	string GetPK(string table){
		
		string sql=@"SELECT KCU.COLUMN_NAME 
			FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE KCU
			JOIN INFORMATION_SCHEMA.TABLE_CONSTRAINTS TC
			ON KCU.CONSTRAINT_NAME=TC.CONSTRAINT_NAME
			WHERE TC.CONSTRAINT_TYPE='PRIMARY KEY'
			AND KCU.TABLE_NAME=@tableName";

		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=sql;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=table;
			cmd.Parameters.Add(p);

			var result=cmd.ExecuteScalar();

			if(result!=null)
				return result.ToString();    
		}	         
		
		return "";
	}
	
	string GetPropertyType(string sqlType)
	{
		string sysType="string";
		switch (sqlType) 
		{
			case "bigint":
				sysType = "long";
				break;
			case "smallint":
				sysType= "short";
				break;
			case "int":
				sysType= "int";
				break;
			case "uniqueidentifier":
				sysType=  "Guid";
				 break;
			case "smalldatetime":
			case "datetime":
			case "date":
			case "time":
				sysType=  "DateTime";
				  break;
			case "float":
				sysType="double";
				break;
			case "real":
				sysType="float";
				break;
			case "numeric":
			case "smallmoney":
			case "decimal":
			case "money":
				sysType=  "decimal";
				 break;
			case "tinyint":
				sysType = "byte";
				break;
			case "bit":
				sysType=  "bool";
				   break;
			case "image":
			case "binary":
			case "varbinary":
			case "timestamp":
				sysType=  "byte[]";
				 break;
		}
		return sysType;
	}



	const string TABLE_SQL=@"SELECT *
		FROM  INFORMATION_SCHEMA.TABLES
		WHERE TABLE_TYPE='TABLE'";

	const string COLUMN_SQL=@"SELECT 
			TABLE_CATALOG AS [Database],
			TABLE_SCHEMA AS Owner, 
			TABLE_NAME AS TableName, 
			COLUMN_NAME AS ColumnName, 
			ORDINAL_POSITION AS OrdinalPosition, 
			COLUMN_DEFAULT AS DefaultSetting, 
			IS_NULLABLE AS IsNullable, DATA_TYPE AS DataType, 
			AUTOINC_INCREMENT,
			CHARACTER_MAXIMUM_LENGTH AS MaxLength, 
			DATETIME_PRECISION AS DatePrecision
		FROM  INFORMATION_SCHEMA.COLUMNS
		WHERE TABLE_NAME=@tableName
		ORDER BY OrdinalPosition ASC";
}


public class PostGreSqlSchemaReader : SchemaReader
{
	public override List<string> GetStoredProcedures(DbConnection connection)
	{
		return new List<string>();
	}
	
	public override Dictionary<string, List<string>> GetTVPs(DbConnection connection)
	{
		return new Dictionary<string, List<string>>();
	}

	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();
		
		_connection=connection;

		var cmd=_connection.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText=TABLE_SQL;

		//pull the tables in a reader
		using(cmd)
		{
			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["table_name"].ToString();
					tbl.Schema=rdr["table_schema"].ToString();
					tbl.IsView=string.Compare(rdr["table_type"].ToString(), "View", true)==0;
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=Inflector.MakeSingular(tbl.CleanName);
					result.Add(tbl);
				}
			}
		}

		foreach (var tbl in result)
		{
			tbl.Columns=LoadColumns(tbl);
		            
			// Mark the primary key
			string PrimaryKey=GetPK(tbl.Name);
			var pkColumn=tbl.Columns.SingleOrDefault(x=>x.Name.ToLower().Trim()==PrimaryKey.ToLower().Trim());
			if(pkColumn!=null)
				pkColumn.IsPK=true;
		}
	    

		return result;
	}
	
	DbConnection _connection;
	

	List<Column> LoadColumns(Table tbl)
	{
	
		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=COLUMN_SQL;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=tbl.Name;
			cmd.Parameters.Add(p);

			var result=new List<Column>();
			using (IDataReader rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Column col=new Column();
					col.Name=rdr["column_name"].ToString();
					col.PropertyName=CleanUp(col.Name);
					col.PropertyType=GetPropertyType(rdr["udt_name"].ToString());
					col.IsNullable=rdr["is_nullable"].ToString()=="YES";
					col.IsAutoIncrement = rdr["column_default"].ToString().StartsWith("nextval(");
					result.Add(col);
				}
			}

			return result;
		}
	}

	string GetPK(string table){
		
		string sql=@"SELECT kcu.column_name 
			FROM information_schema.key_column_usage kcu
			JOIN information_schema.table_constraints tc
			ON kcu.constraint_name=tc.constraint_name
			WHERE lower(tc.constraint_type)='primary key'
			AND kcu.table_name=@tablename";

		using (var cmd=_connection.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=sql;

			var p = cmd.CreateParameter();
			p.ParameterName = "@tableName";
			p.Value=table;
			cmd.Parameters.Add(p);

			var result=cmd.ExecuteScalar();

			if(result!=null)
				return result.ToString();    
		}	         
		
		return "";
	}
	
	string GetPropertyType(string sqlType)
	{
		switch (sqlType)
		{
			case "int8":
			case "serial8":	
				return "long";

			case "bool":	
				return "bool";

			case "bytea	":	
				return "byte[]";

			case "float8":	
				return "double";

			case "int4":	
			case "serial4":	
				return "int";

			case "money	":	
				return "decimal";

			case "numeric":	
				return "decimal";

			case "float4":	
				return "float";

			case "int2":	
				return "short";

			case "time":
			case "timetz":
			case "timestamp":
			case "timestamptz":	
			case "date":	
				return "DateTime";

			default:
				return "string";
		}
	}



	const string TABLE_SQL=@"
			SELECT table_name, table_schema, table_type
			FROM information_schema.tables 
			WHERE (table_type='BASE TABLE' OR table_type='VIEW')
				AND table_schema NOT IN ('pg_catalog', 'information_schema');
			";

	const string COLUMN_SQL=@"
			SELECT column_name, is_nullable, udt_name, column_default
			FROM information_schema.columns 
			WHERE table_name=@tableName;
			";
	
}

public class MySqlSchemaReader : SchemaReader
{
	public override List<string> GetStoredProcedures(DbConnection connection)
	{
		return new List<string>();
	}
	
	public override Dictionary<string, List<string>> GetTVPs(DbConnection connection)
	{
		return new Dictionary<string, List<string>>();
	}

	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();
	

		var cmd=connection.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText=TABLE_SQL;

		//pull the tables in a reader
		using(cmd)
		{
			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["TABLE_NAME"].ToString();
					tbl.Schema=rdr["TABLE_SCHEMA"].ToString();
					tbl.IsView=string.Compare(rdr["TABLE_TYPE"].ToString(), "View", true)==0;
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=Inflector.MakeSingular(tbl.CleanName);
					result.Add(tbl);
				}
			}
		}


        //this will return everything for the DB
        var schema  = connection.GetSchema("COLUMNS");

        //loop again - but this time pull by table name
        foreach (var item in result) 
        {
            item.Columns=new List<Column>();

            //pull the columns from the schema
            var columns = schema.Select("TABLE_NAME='" + item.Name + "'");
            foreach (var row in columns) 
            {
                Column col=new Column();
                col.Name=row["COLUMN_NAME"].ToString();
                col.PropertyName=CleanUp(col.Name);
                col.PropertyType=GetPropertyType(row);
                col.IsNullable=row["IS_NULLABLE"].ToString()=="YES";
                col.IsPK=row["COLUMN_KEY"].ToString()=="PRI";
				col.IsAutoIncrement=row["extra"].ToString().ToLower().IndexOf("auto_increment")>=0;

                item.Columns.Add(col);
            }
        }
        
        return result;
	
	}

	static string GetPropertyType(DataRow row)
	{
		bool bUnsigned = row["COLUMN_TYPE"].ToString().IndexOf("unsigned")>=0;
		string propType="string";
		switch (row["DATA_TYPE"].ToString()) 
		{
			case "bigint":
				propType= bUnsigned ? "ulong" : "long";
				break;
			case "int":
				propType= bUnsigned ? "uint" : "int";
				break;
			case "smallint":
				propType= bUnsigned ? "ushort" : "short";
				break;
			case "guid":
				propType=  "Guid";
				 break;
			case "smalldatetime":
			case "date":
			case "datetime":
			case "timestamp":
				propType=  "DateTime";
				  break;
			case "float":
				propType="float";
				break;
			case "double":
				propType="double";
				break;
			case "numeric":
			case "smallmoney":
			case "decimal":
			case "money":
				propType=  "decimal";
				 break;
			case "bit":
			case "bool":
			case "boolean":
				propType=  "bool";
				break;
			case "tinyint":
				propType =  bUnsigned ? "byte" : "sbyte";
				break;
			case "image":
			case "binary":
			case "blob":
			case "mediumblob":
			case "longblob":
			case "varbinary":
				propType=  "byte[]";
				 break;
				 
		}
		return propType;
	}

	const string TABLE_SQL=@"
			SELECT * 
			FROM information_schema.tables 
			WHERE (table_type='BASE TABLE' OR table_type='VIEW')
			";

}

public class OracleSchemaReader : SchemaReader
{
	public override List<string> GetStoredProcedures(DbConnection connection)
	{
		return new List<string>();
	}

	public override Dictionary<string, List<string>> GetTVPs(DbConnection connection)
	{
		return new Dictionary<string, List<string>>();
	}

	// SchemaReader.ReadSchema
	public override Tables ReadSchema(DbConnection connection)
	{
		var result=new Tables();
		
		_connection=connection;

		var cmd=_connection.CreateCommand();
		cmd.Connection=connection;
		cmd.CommandText=TABLE_SQL;
		cmd.GetType().GetProperty("BindByName").SetValue(cmd, true, null);

		//pull the tables in a reader
		using(cmd)
		{

			using (var rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Table tbl=new Table();
					tbl.Name=rdr["TABLE_NAME"].ToString();
					tbl.Schema = rdr["TABLE_SCHEMA"].ToString();
					tbl.IsView=string.Compare(rdr["TABLE_TYPE"].ToString(), "View", true)==0;
					tbl.CleanName=CleanUp(tbl.Name);
					tbl.ClassName=Inflector.MakeSingular(tbl.CleanName);
					result.Add(tbl);
				}
			}
		}

		foreach (var tbl in result)
		{
			tbl.Columns=LoadColumns(tbl);
		            
			// Mark the primary key
			string PrimaryKey=GetPK(tbl.Name);
			var pkColumn=tbl.Columns.SingleOrDefault(x=>x.Name.ToLower().Trim()==PrimaryKey.ToLower().Trim());
			if(pkColumn!=null)
				pkColumn.IsPK=true;
		}
	    

		return result;
	}
	
	DbConnection _connection;
	DbProviderFactory _factory;
	

	List<Column> LoadColumns(Table tbl)
	{
	
		using (var cmd=_factory.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=COLUMN_SQL;
			cmd.GetType().GetProperty("BindByName").SetValue(cmd, true, null);

			var p = cmd.CreateParameter();
			p.ParameterName = ":tableName";
			p.Value=tbl.Name;
			cmd.Parameters.Add(p);

			var result=new List<Column>();
			using (IDataReader rdr=cmd.ExecuteReader())
			{
				while(rdr.Read())
				{
					Column col=new Column();
					col.Name=rdr["ColumnName"].ToString();
					col.PropertyName=CleanUp(col.Name);
					col.PropertyType=GetPropertyType(rdr["DataType"].ToString(), (rdr["DataType"] == DBNull.Value ? null : rdr["DataType"].ToString()));
					col.IsNullable=rdr["IsNullable"].ToString()=="YES";
					col.IsAutoIncrement=true;
					result.Add(col);
				}
			}

			return result;
		}
	}

	string GetPK(string table){
		
		string sql=@"select column_name from USER_CONSTRAINTS uc
  inner join USER_CONS_COLUMNS ucc on uc.constraint_name = ucc.constraint_name
where uc.constraint_type = 'P'
and uc.table_name = upper(:tableName)
and ucc.position = 1";

		using (var cmd=_factory.CreateCommand())
		{
			cmd.Connection=_connection;
			cmd.CommandText=sql;
			cmd.GetType().GetProperty("BindByName").SetValue(cmd, true, null);

			var p = cmd.CreateParameter();
			p.ParameterName = ":tableName";
			p.Value=table;
			cmd.Parameters.Add(p);

			var result=cmd.ExecuteScalar();

			if(result!=null)
				return result.ToString();    
		}	         
		
		return "";
	}
	
	string GetPropertyType(string sqlType, string dataScale)
	{
		string sysType="string";
		switch (sqlType.ToLower()) 
		{
			case "bigint":
				sysType = "long";
				break;
			case "smallint":
				sysType= "short";
				break;
			case "int":
				sysType= "int";
				break;
			case "uniqueidentifier":
				sysType=  "Guid";
				 break;
			case "smalldatetime":
			case "datetime":
			case "date":
				sysType=  "DateTime";
				  break;
			case "float":
				sysType="double";
				break;
			case "real":
			case "numeric":
			case "smallmoney":
			case "decimal":
			case "money":
			case "number":
				sysType=  "decimal";
				 break;
			case "tinyint":
				sysType = "byte";
				break;
			case "bit":
				sysType=  "bool";
				   break;
			case "image":
			case "binary":
			case "varbinary":
			case "timestamp":
				sysType=  "byte[]";
				 break;
		}
		
		if (sqlType == "number" && dataScale == "0")
			return "long";
		
		return sysType;
	}



	const string TABLE_SQL=@"select TABLE_NAME from USER_TABLES";

	const string COLUMN_SQL=@"select table_name TableName, 
 column_name ColumnName, 
 data_type DataType, 
 data_scale DataScale,
 nullable IsNullable
 from USER_TAB_COLS utc 
 where table_name = upper(:tableName)
 order by column_id";
	  
}



/// <summary>
/// Summary for the Inflector class
/// </summary>
public static class Inflector {
    private static readonly List<InflectorRule> _plurals = new List<InflectorRule>();
    private static readonly List<InflectorRule> _singulars = new List<InflectorRule>();
    private static readonly List<string> _uncountables = new List<string>();

    /// <summary>
    /// Initializes the <see cref="Inflector"/> class.
    /// </summary>
    static Inflector() {
        AddPluralRule("$", "s");
        AddPluralRule("s$", "s");
        AddPluralRule("(ax|test)is$", "$1es");
        AddPluralRule("(octop|vir)us$", "$1i");
        AddPluralRule("(alias|status)$", "$1es");
        AddPluralRule("(bu)s$", "$1ses");
        AddPluralRule("(buffal|tomat)o$", "$1oes");
        AddPluralRule("([ti])um$", "$1a");
        AddPluralRule("sis$", "ses");
        AddPluralRule("(?:([^f])fe|([lr])f)$", "$1$2ves");
        AddPluralRule("(hive)$", "$1s");
        AddPluralRule("([^aeiouy]|qu)y$", "$1ies");
        AddPluralRule("(x|ch|ss|sh)$", "$1es");
        AddPluralRule("(matr|vert|ind)ix|ex$", "$1ices");
        AddPluralRule("([m|l])ouse$", "$1ice");
        AddPluralRule("^(ox)$", "$1en");
        AddPluralRule("(quiz)$", "$1zes");

        AddSingularRule("s$", String.Empty);
        AddSingularRule("ss$", "ss");
		AddSingularRule("Cms$", "Cms");
        AddSingularRule("(n)ews$", "$1ews");
        //AddSingularRule("([ti])a$", "$1um");
        AddSingularRule("((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$", "$1$2sis");
        AddSingularRule("(^analy)ses$", "$1sis");
        AddSingularRule("([^f])ves$", "$1fe");
        AddSingularRule("(hive)s$", "$1");
        AddSingularRule("(tive)s$", "$1");
        AddSingularRule("([lr])ves$", "$1f");
        AddSingularRule("([^aeiouy]|qu)ies$", "$1y");
        AddSingularRule("(s)eries$", "$1eries");
        AddSingularRule("(m)ovies$", "$1ovie");
        AddSingularRule("(x|ch|ss|sh)es$", "$1");
        AddSingularRule("([m|l])ice$", "$1ouse");
        AddSingularRule("(bus)es$", "$1");
        AddSingularRule("(o)es$", "$1");
        AddSingularRule("(shoe)s$", "$1");
        AddSingularRule("(cris|ax|test)es$", "$1is");
        AddSingularRule("(octop|vir)i$", "$1us");
        AddSingularRule("(alias|status)$", "$1");
        AddSingularRule("(alias|status)es$", "$1");
        AddSingularRule("^(ox)en", "$1");
        AddSingularRule("(vert|ind)ices$", "$1ex");
        AddSingularRule("(matr)ices$", "$1ix");
        AddSingularRule("(quiz)zes$", "$1");

        AddIrregularRule("person", "people");
        AddIrregularRule("man", "men");
        AddIrregularRule("child", "children");
        AddIrregularRule("sex", "sexes");
        AddIrregularRule("tax", "taxes");
        AddIrregularRule("move", "moves");

        AddUnknownCountRule("equipment");
        AddUnknownCountRule("information");
        AddUnknownCountRule("rice");
        AddUnknownCountRule("money");
        AddUnknownCountRule("species");
        AddUnknownCountRule("series");
        AddUnknownCountRule("fish");
        AddUnknownCountRule("sheep");
    }

    /// <summary>
    /// Adds the irregular rule.
    /// </summary>
    /// <param name="singular">The singular.</param>
    /// <param name="plural">The plural.</param>
    private static void AddIrregularRule(string singular, string plural) {
        AddPluralRule(String.Concat("(", singular[0], ")", singular.Substring(1), "$"), String.Concat("$1", plural.Substring(1)));
        AddSingularRule(String.Concat("(", plural[0], ")", plural.Substring(1), "$"), String.Concat("$1", singular.Substring(1)));
    }

    /// <summary>
    /// Adds the unknown count rule.
    /// </summary>
    /// <param name="word">The word.</param>
    private static void AddUnknownCountRule(string word) {
        _uncountables.Add(word.ToLower());
    }

    /// <summary>
    /// Adds the plural rule.
    /// </summary>
    /// <param name="rule">The rule.</param>
    /// <param name="replacement">The replacement.</param>
    private static void AddPluralRule(string rule, string replacement) {
        _plurals.Add(new InflectorRule(rule, replacement));
    }

    /// <summary>
    /// Adds the singular rule.
    /// </summary>
    /// <param name="rule">The rule.</param>
    /// <param name="replacement">The replacement.</param>
    private static void AddSingularRule(string rule, string replacement) {
        _singulars.Add(new InflectorRule(rule, replacement));
    }

    /// <summary>
    /// Makes the plural.
    /// </summary>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    public static string MakePlural(string word) {
        return ApplyRules(_plurals, word);
    }

    /// <summary>
    /// Makes the singular.
    /// </summary>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    public static string MakeSingular(string word) {
        return ApplyRules(_singulars, word);
    }

    /// <summary>
    /// Applies the rules.
    /// </summary>
    /// <param name="rules">The rules.</param>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    private static string ApplyRules(IList<InflectorRule> rules, string word) {
        string result = word;
        if (!_uncountables.Contains(word.ToLower())) {
            for (int i = rules.Count - 1; i >= 0; i--) {
                string currentPass = rules[i].Apply(word);
                if (currentPass != null) {
                    result = currentPass;
                    break;
                }
            }
        }
        return result;
    }

    /// <summary>
    /// Converts the string to title case.
    /// </summary>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    public static string ToTitleCase(string word) {
        return Regex.Replace(ToHumanCase(AddUnderscores(word)), @"\b([a-z])",
            delegate(Match match) { return match.Captures[0].Value.ToUpper(); });
    }

    /// <summary>
    /// Converts the string to human case.
    /// </summary>
    /// <param name="lowercaseAndUnderscoredWord">The lowercase and underscored word.</param>
    /// <returns></returns>
    public static string ToHumanCase(string lowercaseAndUnderscoredWord) {
        return MakeInitialCaps(Regex.Replace(lowercaseAndUnderscoredWord, @"_", " "));
    }


    /// <summary>
    /// Adds the underscores.
    /// </summary>
    /// <param name="pascalCasedWord">The pascal cased word.</param>
    /// <returns></returns>
    public static string AddUnderscores(string pascalCasedWord) {
        return Regex.Replace(Regex.Replace(Regex.Replace(pascalCasedWord, @"([A-Z]+)([A-Z][a-z])", "$1_$2"), @"([a-z\d])([A-Z])", "$1_$2"), @"[-\s]", "_").ToLower();
    }

    /// <summary>
    /// Makes the initial caps.
    /// </summary>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    public static string MakeInitialCaps(string word) {
        return String.Concat(word.Substring(0, 1).ToUpper(), word.Substring(1).ToLower());
    }

    /// <summary>
    /// Makes the initial lower case.
    /// </summary>
    /// <param name="word">The word.</param>
    /// <returns></returns>
    public static string MakeInitialLowerCase(string word) {
        return String.Concat(word.Substring(0, 1).ToLower(), word.Substring(1));
    }


    /// <summary>
    /// Determine whether the passed string is numeric, by attempting to parse it to a double
    /// </summary>
    /// <param name="str">The string to evaluated for numeric conversion</param>
    /// <returns>
    /// 	<c>true</c> if the string can be converted to a number; otherwise, <c>false</c>.
    /// </returns>
    public static bool IsStringNumeric(string str) {
        double result;
        return (double.TryParse(str, NumberStyles.Float, NumberFormatInfo.CurrentInfo, out result));
    }

    /// <summary>
    /// Adds the ordinal suffix.
    /// </summary>
    /// <param name="number">The number.</param>
    /// <returns></returns>
    public static string AddOrdinalSuffix(string number) {
        if (IsStringNumeric(number)) {
            int n = int.Parse(number);
            int nMod100 = n % 100;

            if (nMod100 >= 11 && nMod100 <= 13)
                return String.Concat(number, "th");

            switch (n % 10) {
                case 1:
                    return String.Concat(number, "st");
                case 2:
                    return String.Concat(number, "nd");
                case 3:
                    return String.Concat(number, "rd");
                default:
                    return String.Concat(number, "th");
            }
        }
        return number;
    }

    /// <summary>
    /// Converts the underscores to dashes.
    /// </summary>
    /// <param name="underscoredWord">The underscored word.</param>
    /// <returns></returns>
    public static string ConvertUnderscoresToDashes(string underscoredWord) {
        return underscoredWord.Replace('_', '-');
    }


    #region Nested type: InflectorRule

    /// <summary>
    /// Summary for the InflectorRule class
    /// </summary>
    private class InflectorRule {
        /// <summary>
        /// 
        /// </summary>
        public readonly Regex regex;

        /// <summary>
        /// 
        /// </summary>
        public readonly string replacement;

        /// <summary>
        /// Initializes a new instance of the <see cref="InflectorRule"/> class.
        /// </summary>
        /// <param name="regexPattern">The regex pattern.</param>
        /// <param name="replacementText">The replacement text.</param>
        public InflectorRule(string regexPattern, string replacementText) {
            regex = new Regex(regexPattern, RegexOptions.IgnoreCase);
            replacement = replacementText;
        }

        /// <summary>
        /// Applies the specified word.
        /// </summary>
        /// <param name="word">The word.</param>
        /// <returns></returns>
        public string Apply(string word) {
            if (!regex.IsMatch(word))
                return null;

            string replace = regex.Replace(word, replacement);
            if (word == word.ToUpper())
                replace = replace.ToUpper();

            return replace;
        }
    }

    #endregion
}
